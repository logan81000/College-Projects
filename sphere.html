<!DOCTYPE html>
<html>
<body>
<style>
#button-container {
    display: flex;
    flex-direction: row;
    margin: 0 0 0 10px;
}

button {
    background-color: black;
    border: none;
    color: white;
    padding: 15px 15px;
    text-align: left;
    text-decoration: none;
    display: inline-block;
    font-size: 18px;
    margin: 4px 2px;
    cursor: pointer;
}

.instructions {
    margin-left: 5px;
}
</style>
<canvas id="canvas" width="500" height="500"></canvas>
<div id="button-container">
<button id="increase-subdivision">Increase Subdivisions</button>
<button id="decrease-subdivision">Decrease Subdivisions</button>
<button id="reset-button">Reset</button>
</div>
<div>
<br>
<p>Use the arrow buttons to rotate the sphere:</p>
<ul class="instructions">
<li>&and; : Increase Phi</li>
<li>&or; : Decrease Phi</li>
<li>&lt; : Increase Theta</li>
<li>&gt; : Decrease Theta</li>
</ul>
</div>

<script src="sphere.js"></script>
<script type="text/javascript">

var numTimesToSubdivide = 3;
var ind = 0;
var pos = [];
var near = -10;
var far = 10;
var rad = 3.0;
var theta = 0.0;
var phi = 0.0;
var dr = 5.0 * Math.PI / 180.0;
var left = -2.0;
var right = 2.0;
var y = 2.0;
var bot = -2.0;
var modelmat, projmat;
var modelmatLoc, projmatLoc;
var eye;
const at = vec3(0.0, 0.0, 0.0);
const up = vec3(0.0, 1.0, 0.0);
function tri(a, b, c) {
	pos.push(a);
	pos.push(b);
	pos.push(c);
	ind += 3;
}
function dividetri(a, b, c, count) {
	if (count > 0) {
		var ab = normalize(mix(a, b, 0.5), true);
		var ac = normalize(mix(a, c, 0.5), true);
		var bc = normalize(mix(b, c, 0.5), true);
		dividetri(a, ab, ac, count - 1);
		dividetri(ab, b, bc, count - 1);
		dividetri(bc, c, ac, count - 1);
		dividetri(ab, bc, ac, count - 1);
	}
	else {
		tri(a, b, c);
	}
}
function tetra(a, b, c, d, n) {
	dividetri(a, b, c, n);
	dividetri(d, c, b, n);
	dividetri(a, d, b, n);
	dividetri(a, c, d, n);
}

const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LESS);
gl.enable(gl.POLYGON_OFFSET_FILL);
gl.polygonOffset(1.0, 2.0);
document.getElementById("increase-subdivision").addEventListener("click", function () {
	if (numTimesToSubdivide < 8) {
		numTimesToSubdivide++;
		ind = 0;
		pos = [];
		tetra(va, vb, vc, vd, numTimesToSubdivide); 
		gl.bufferData(gl.ARRAY_BUFFER, flatten(pos), gl.STATIC_DRAW);
	}
});
document.getElementById("decrease-subdivision").addEventListener("click", function () {
	if (numTimesToSubdivide > 0) {
		numTimesToSubdivide--;
		ind = 0;
		pos = [];
		tetra(va, vb, vc, vd, numTimesToSubdivide);
		gl.bufferData(gl.ARRAY_BUFFER, flatten(pos), gl.STATIC_DRAW);
		}
});
document.getElementById("reset-button").addEventListener("click", function () {
	numTimesToSubdivide = 3;
	ind = 0;
	pos = [];
	theta = 0.0;
	phi = 0.0;
	tetra(va, vb, vc, vd, numTimesToSubdivide);
	gl.bufferData(gl.ARRAY_BUFFER, flatten(pos), gl.STATIC_DRAW);
});

let butheld = false;
window.addEventListener('keydown', function (event) {
	switch (event.keyCode) {
		case 37:
		if (!butheld) {
			butheld = true;
			let timer = setInterval(function () {
				theta += Math.PI / 90;
			}, 1000 / 60);
			window.addEventListener('keyup', function stopRotation() {
				butheld = false;
				clearInterval(timer);
				window.removeEventListener('keyup', stopRotation);
			});
		}
		break;
		case 38:

		if (!butheld) {
			butheld = true;

			let timer = setInterval(function () {
				phi += Math.PI / 90;
			}, 1000 / 60);
			window.addEventListener('keyup', function stopRotation() {
				butheld = false;
				clearInterval(timer);
				window.removeEventListener('keyup', stopRotation);
			});
		}
		break;
		case 39:
		if (!butheld) {
			butheld = true;
			let timer = setInterval(function () {
				theta -= Math.PI / 90;
			}, 1000 / 60);
			window.addEventListener('keyup', function stopRotation() {
				butheld = false;
				clearInterval(timer);
				window.removeEventListener('keyup', stopRotation);
			});
		}
		break;
		case 40:
		if (!butheld) {
			butheld = true;
			let timer = setInterval(function () {
				phi -= Math.PI / 90;
			}, 1000 / 60);
			window.addEventListener('keyup', function stopRotation() {
				butheld = false;
				clearInterval(timer);
				window.removeEventListener('keyup', stopRotation);
			});
		}
		break;
	}
});
var vertshad = gl.createShader(gl.VERTEX_SHADER);
var vertshadSource = `
attribute vec4 aVertexPosition;
uniform mat4 umodelmat;
uniform mat4 uprojmat;
void main() {
	gl_Position = uprojmat * umodelmat * aVertexPosition;
}
`;
gl.shaderSource(vertshad, vertshadSource);
gl.compileShader(vertshad);

var fragshad = gl.createShader(gl.FRAGMENT_SHADER);
var fragshadSource = `
precision mediump float;
void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}
`;
gl.shaderSource(fragshad, fragshadSource);
gl.compileShader(fragshad);
var program = gl.createProgram();
gl.attachShader(program, vertshad);
gl.attachShader(program, fragshad);
gl.linkProgram(program);
gl.useProgram(program);
var va = vec4(0.0, 0.0, -1.0, 1);
var vb = vec4(0.0, 0.942809, 0.333333, 1);
var vc = vec4(-0.816497, -0.471405, 0.333333, 1);
var vd = vec4(0.816497, -0.471405, 0.333333, 1);
tetra(va, vb, vc, vd, numTimesToSubdivide);
var positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, flatten(pos), gl.STATIC_DRAW);
var aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
gl.vertexAttribPointer(aVertexPosition, 4, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aVertexPosition);
umodelmat = gl.getUniformLocation(program, 'umodelmat');
uprojmat = gl.getUniformLocation(program, 'uprojmat');
function render() {
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	eye = vec3(rad * Math.sin(theta) * Math.cos(phi),
	rad * Math.sin(theta) * Math.sin(phi), rad * Math.cos(theta));
	modelmat = lookAt(eye, at, up);
	projmat = ortho(left, right, bot, y, near, far);
	gl.uniformMatrix4fv(umodelmat, false, flatten(modelmat));
	gl.uniformMatrix4fv(uprojmat, false, flatten(projmat));
	for (var i = 0; i < ind; i += 3) {
		gl.drawArrays(gl.LINE_LOOP, i, 3);
	}
	requestAnimationFrame(render);
}
render();
</script>
</body>
</html>